// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: book_genres.sql

package db

import (
	"context"
)

type CreateBookGenresParams struct {
	BookID  int64 `json:"book_id"`
	GenreID int64 `json:"genre_id"`
}

const deleteBookGenre = `-- name: DeleteBookGenre :exec
DELETE FROM
  book_genres
WHERE
  genre_id = $1
`

func (q *Queries) DeleteBookGenre(ctx context.Context, genreID int64) error {
	_, err := q.db.Exec(ctx, deleteBookGenre, genreID)
	return err
}

const deleteGenreByBookIds = `-- name: DeleteGenreByBookIds :exec
DELETE FROM
  book_genres
WHERE
  book_id = ANY($1::int[])
`

func (q *Queries) DeleteGenreByBookIds(ctx context.Context, dollar_1 []int32) error {
	_, err := q.db.Exec(ctx, deleteGenreByBookIds, dollar_1)
	return err
}

const getBookGenres = `-- name: GetBookGenres :many
SELECT
  bg.book_id, bg.genre_id,
  g.name
from
  book_genres bg
  join genres g on bg.genre_id = g.genre_id
where
  bg.book_id = $1
`

type GetBookGenresRow struct {
	BookID  int64  `json:"book_id"`
	GenreID int64  `json:"genre_id"`
	Name    string `json:"name"`
}

func (q *Queries) GetBookGenres(ctx context.Context, bookID int64) ([]GetBookGenresRow, error) {
	rows, err := q.db.Query(ctx, getBookGenres, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBookGenresRow{}
	for rows.Next() {
		var i GetBookGenresRow
		if err := rows.Scan(&i.BookID, &i.GenreID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
